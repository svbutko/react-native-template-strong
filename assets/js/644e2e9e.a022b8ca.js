"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1577],{8350:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=t(4848),i=t(8453);const s={sidebar_position:13,title:"Validations"},r=void 0,o={id:"validations",title:"Validations",description:"Content",source:"@site/docs/validations.md",sourceDirName:".",slug:"/validations",permalink:"/react-native-template-strong/docs/validations",draft:!1,unlisted:!1,editUrl:"https://github.com/svbutko/react-native-template-strong/master/website/docs/validations.md",tags:[],version:"current",lastUpdatedAt:1634026274e3,sidebarPosition:13,frontMatter:{sidebar_position:13,title:"Validations"},sidebar:"tutorialSidebar",previous:{title:"shareHelpers",permalink:"/react-native-template-strong/docs/helpers/share-helpers"},next:{title:"newState",permalink:"/react-native-template-strong/docs/utils/new-state"}},l={},c=[{value:"Content",id:"content",level:2},{value:"Validations",id:"validations",level:2},{value:"emptyValidation",id:"emptyvalidation",level:3},{value:"datesValidation",id:"datesvalidation",level:3},{value:"phoneValidations",id:"phonevalidations",level:3},{value:"emailValidations",id:"emailvalidations",level:3},{value:"fullNameValidations",id:"fullnamevalidations",level:3},{value:"Validation constants",id:"validation-constants",level:2},{value:"Hooks",id:"hooks",level:2},{value:"useInputError",id:"useinputerror",level:3},{value:"Async thunk error handling",id:"async-thunk-error-handling",level:2},{value:"handlePromiseResult",id:"handlepromiseresult",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"content",children:"Content"}),"\n",(0,a.jsx)(n.p,{children:"Primarily has validations for different use cases (e.g. min. password length, max. name characters etc.)."}),"\n",(0,a.jsxs)(n.p,{children:["Many of those validations can be used with ",(0,a.jsx)(n.code,{children:"PrimaryTextInput"})," to show errors while user types, when user finished typing (left input) or when user taps on a certain button."]}),"\n",(0,a.jsxs)(n.p,{children:["These validations are located in the ",(0,a.jsx)(n.code,{children:"src/common/validations"})," folder."]}),"\n",(0,a.jsx)(n.h2,{id:"validations",children:"Validations"}),"\n",(0,a.jsxs)(n.p,{children:["These validations operate with ",(0,a.jsx)(n.code,{children:"null | string"})," return type rather than throwing an error. So when a method returns ",(0,a.jsx)(n.code,{children:"null"})," then a value passed, otherwise it returns localized ",(0,a.jsx)(n.code,{children:"string"})," which can be shown to user as error."]}),"\n",(0,a.jsx)(n.h3,{id:"emptyvalidation",children:"emptyValidation"}),"\n",(0,a.jsxs)(n.p,{children:["Checks whether a string is empty (returns localization string) or not (returns ",(0,a.jsx)(n.code,{children:"null"}),")."]}),"\n",(0,a.jsx)(n.h3,{id:"datesvalidation",children:"datesValidation"}),"\n",(0,a.jsx)(n.p,{children:"Compares two dates between each other.\nIf dates are equal then returns localization string (dates can't be equal).\nThen based on which field is currently being filled checks the difference:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"from"})," can't be later than ",(0,a.jsx)(n.code,{children:"to"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"to"})," can't be earlier than ",(0,a.jsx)(n.code,{children:"from"})]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"phonevalidations",children:"phoneValidations"}),"\n",(0,a.jsx)(n.p,{children:"Checks whether a string is empty or not and checks minimal length of phone number."}),"\n",(0,a.jsx)(n.h3,{id:"emailvalidations",children:"emailValidations"}),"\n",(0,a.jsxs)(n.p,{children:["Checks whether a string is empty or not and checks the format of email by using ",(0,a.jsx)(n.code,{children:"isEmail"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"fullnamevalidations",children:"fullNameValidations"}),"\n",(0,a.jsx)(n.p,{children:"Checks whether a string is empty or not and checks minimal length of full name."}),"\n",(0,a.jsx)(n.h2,{id:"validation-constants",children:"Validation constants"}),"\n",(0,a.jsxs)(n.p,{children:["These constants can be used as min/max length props in text inputs or when checking certain values.\nThey are located in ",(0,a.jsx)(n.code,{children:"validationConstants.ts"})," and have some common values:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export const validationConstants = {\n  phone: {\n    minLength: 8,\n    maxLength: 18,\n  },\n  fullName: {\n    minLength: 3,\n    maxLength: 64,\n  },\n  comment: {\n    maxLength: 280,\n  },\n  email: {\n    maxLength: 254,\n  },\n  licensePlate: {\n    minLength: 4,\n    maxLength: 10,\n  },\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"hooks",children:"Hooks"}),"\n",(0,a.jsx)(n.p,{children:"There are a couple of hooks to use for error checking when user does certain actions. So rather than using 3rd party form dependency\n(forms are rare use case and for most of the time can be checked manually in React Native) it's more convenient to use this custom hooks"}),"\n",(0,a.jsx)(n.h3,{id:"useinputerror",children:"useInputError"}),"\n",(0,a.jsxs)(n.p,{children:["Checks string value which user inputs based on supplied validation and returns ",(0,a.jsx)(n.code,{children:"error"}),", ",(0,a.jsx)(n.code,{children:"setError"}),", ",(0,a.jsx)(n.code,{children:"recheck"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Used in conjunction with ",(0,a.jsx)(n.code,{children:"recheckAllValidations"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["To better demonstrate how it works, it's better to show a basic example with ",(0,a.jsx)(n.code,{children:"email"})," and ",(0,a.jsx)(n.code,{children:"name"})," text inputs:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",metastring:"jsx",children:'export const AuthPersonalData: NavigationFunctionComponent = () => {\n    const dispatch = useAppDispatch();\n\n    const [fullName, setFullName] = useState<string>("");\n    const [email, setEmail] = useState<string>("");\n\n    const {error: emailError, recheckValue: recheckEmail} = useInputError(email, emailValidations);\n    const {error: nameError, recheckValue: recheckName} = useInputError(fullName, fullNameValidations);\n    \n    const submitData = useCallback(() => {\n        if (recheckAllValidations([recheckName, recheckEmail])) {\n            dispatch(createProfile({email, name: fullName.trim()}));\n        }\n    }, [recheckName, recheckEmail, dispatch, email, fullName]);\n\n    return (\n        <SafeAreaView onTouchStart={Keyboard.dismiss} style={CommonStyles.flexWhiteBackground}>\n            <PrimaryTextInput\n                label={localization.common.fullName}\n                value={fullName}\n                onChangeText={setFullName}\n                autoCompleteType={"name"}\n                enablesReturnKeyAutomatically={true}\n                returnKeyType={"next"}\n                textContentType={"name"}\n                maxLength={validationConstants.fullName.maxLength}\n                error={nameError}\n            />\n            <PrimaryTextInput\n                label={localization.common.email}\n                value={email}\n                onChangeText={setEmail}\n                autoCompleteType={"email"}\n                enablesReturnKeyAutomatically={true}\n                returnKeyType={"done"}\n                textContentType={"emailAddress"}\n                autoCapitalize={"none"}\n                blurOnSubmit={true}\n                keyboardType={"email-address"}\n                onSubmitEditing={submitData}\n                maxLength={validationConstants.email.maxLength}\n                error={emailError}\n            />\n            <PrimaryButton\n                type={ButtonType.solid}\n                label={localization.common.addData}\n                onPress={submitData}\n            />\n        </SafeAreaView>\n    );\n};\n'})}),"\n",(0,a.jsx)(n.p,{children:"You can see two simple inputs and a button. While user enters certain value he will be seeing an error if it won't fit to validation."}),"\n",(0,a.jsx)(n.p,{children:"And before dispatching profile creation, we might recheck all validations which we had if at least one of them fails the dispatch won't happen and errors will be set."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"setError"})," parameter which is returned from ",(0,a.jsx)(n.code,{children:"useInputError"})," can be used in cases when we need to manually set error, for example when API returned error regarding this value (e.g. email is already taken)."]}),"\n",(0,a.jsx)(n.h2,{id:"async-thunk-error-handling",children:"Async thunk error handling"}),"\n",(0,a.jsx)(n.p,{children:"To check on async thunk errors and show a success message or show error as alert, toast or input's error prop there's a mechanism for it."}),"\n",(0,a.jsx)(n.h3,{id:"handlepromiseresult",children:"handlePromiseResult"}),"\n",(0,a.jsx)(n.p,{children:"Unwraps the result of promise and then if everything went without errors based on provided params shows success toast and executes success message."}),"\n",(0,a.jsxs)(n.p,{children:["If things went the wrong way it tries to process the error using ",(0,a.jsx)(n.code,{children:"handleErrorPostProcessing"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["To better demonstrate how it works we come back to our example with ",(0,a.jsx)(n.code,{children:"email"})," and ",(0,a.jsx)(n.code,{children:"name"})," but this time we will modify it show error and success message if everything went right."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",metastring:"jsx",children:"    const processError = useCallback((newError: Error) => {\n        return {message: newError.message, visualRepresentation: ErrorRepresentationType.toast}\n    }, []);\n\n    const submitData = useCallback(() => {\n    if (recheckAllValidations([recheckName, recheckEmail])) {\n        handlePromiseResult(\n            dispatch(createProfile({email, name: fullName.trim()}))\n            localization.auth.profileHasBeenSuccessfullyCreated,\n            setAuthorizedRoot,\n            processError\n        );\n    }\n    }, [recheckName, recheckEmail, dispatch, email, fullName]);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["So now if everything goes right user will see a toast with ",(0,a.jsx)(n.code,{children:"localization.auth.profileHasBeenSuccessfullyCreated"})," and will be redirected to new root (",(0,a.jsx)(n.code,{children:"setAuthorizedRoot"}),").\nIf things go wrong way there will be shown a toast with error message from server."]}),"\n",(0,a.jsxs)(n.p,{children:["To better understand logic take a brief look at insides of ",(0,a.jsx)(n.code,{children:"handlePromiseResult"})," and ",(0,a.jsx)(n.code,{children:"handleErrorPostProcessing"})," they are simple but just need to be used once or twice to grasp how and why they do this."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(6540);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);